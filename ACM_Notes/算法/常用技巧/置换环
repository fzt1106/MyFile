# 置换环（求无序序列->有序序列最小交换次数）

## 介绍

### 置换环

对于元素$a_{i,j}$：$i$是$a$在无序序列中的下标，$j$是$a$在有序序列中的下标

对于序列$\{a_{i_1,j_1},a_{i_2,j_2},...,a_{i_n,j_n}\}$，若$j_k=i_{k+1},j_n=i_1$则该序列为一个置换环

> 无序序列
>
> |  1   |  2   |  3   |  4   |  5   |
> | :--: | :--: | :--: | :--: | :--: |
> |  4   |  6   |  7   |  2   |  1   |
>
> 有序序列
>
> |  1   |  2   |  3   |  4   |  5   |
> | :--: | :--: | :--: | :--: | :--: |
> |  1   |  2   |  4   |  6   |  7   |
>
> 于是有：$1_{5,1}$ $2_{4,2}$ $4_{1,3}$ $6_{2,4}$ $7_{3,5}$
>
> 置换环有：$\{1_{5,1},4_{1,3},7_{3,5}\}$,$\{2_{4,2},6_{2,4}\}$

### 重要结论

假设长度为n的序列中，有m个置换环：

1. **有序序列置换环个数为n个**
2. **将一个置换环中任意两个元素交换位置，将会变成两个置换环**
3. **将两个置换环中任意两个元素交换位置，将会变成一个置换环**
4. **将无序序列->有序序列，最小交换次数为n-m**

## 模板（计算置换环个数）

利用并查集，一个置换环即为一个集合

```c++
int n;//序列大小
int a[N];//序列
int pre[N]/*排序前下标为i的位置元素为pre[i]*/;

int par[N];//祖先数组

//并查集查找：找祖先+路径压缩
int find(int x){
    if(par[x]!=x)par[x]=find(par[x]);
    return par[x];
}
//并查集合并
void unite(int x,int y){
    if(find(x)==find(y))return;
    par[find(x)]=find(y);
}

void circle(){
    for(int i=1;i<=n;i++)par[i]=i;//初始化
    for(int i=1;i<=n;i++)pre[i]=a[i];//记录排序前下标为i的位置的元素
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++)unite(a[i],pre[i]);//将排序后下标为i，排序前下标为i的元素所在集合合并
    
    //统计置换环数目（集合的个数）
    int count=0;//置换环数目
    bool vis[N]=0;//判断元素a[i]所在集合是否统计过
    for(int i=1;i<n;i++)
        if(!vis[find(a[i])]){
            count++;
            vis[find(a[i])]=1;
        }
    
    int min_change=n-count;//将无序序列变为有序序列的最小交换次数
}
```


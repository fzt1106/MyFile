# 数位DP

## 介绍

### 思路

对于问题：`区间[l,r]中满足要求的数的个数`此类**计数问题**

+ 若直接暴力遍历判断每个数则需要$O(n)$，但如果$n=1e18$则无法直接暴力遍历。
+ 数位DP的思想就可以**将一个区间的所有数压缩为同一状态**，于是实现$O(1)$遍历一个大区间

数位：把一个数字按照个、十、百、千等等一位一位地拆开，**关注它每一位上的数字**

数位DP：普通的计数（遍历）就是从小到大依次加1把每一个数遍历，但是有些问题中**不同的数的状态其实是相同的(是否满足要求）**，将它们一起压缩为一个状态就可以省去很多判断。如：$[0,999],[1000,1999],[2000,2999],[3000,3999]...$这些区间的遍历都是只有千位数这一位不同，于是可以将这类区间压缩为一个状态，存放进**记忆数组**中，于是遇到类似区间$[1000,1999]$时，就可以$O(1)$得到答案，实现了一步跨越一个大区间

### 辨别

1. 要求统计满足一定条件的数的数量（即，最终目的为**计数**）
2. 若区间为[l,r]，可以通过前缀和思想求[l,r]=[0,r]-[0,l-1]
3. 这些条件经过转化后可以使用「数位」的思想去理解和判断：将不同数可以压缩为同一状态
4. 输入会提供一个数字区间（有时也只提供上界）来作为统计的限制
5. 上界很大（比如1e18），暴力枚举验证会超时（而数位DP复杂度与位数和状态有关，复杂度很小但可以解决1e18的数据）

## 模板

### DFS+记忆化搜索

```c++
long long n;//区间大小
int num[100];//用于存储拆分数
ll dp[100][5][5];//记忆化数组：一定要注意将所有状态（增加维数）都记忆

long long dfs(int index/*当前位*/,int limit,/*当前位是否有限制*/,其他状态){
    if(index==-1)return 具题意判断;
    if(dp[index][limit][其他状态]!=-1)return dp[index][limit][其他状态];
    int end=limit?num[index]:9;//若第index位有限制则遍历0~num[index]，若无限制则遍历0~9
    int ans=0;//统计当前状态的总计数和
    for(int i=0;i<=end;i++){
        ans+=dfs(index-1/*下一位*/,i==end&&limit/*下一位是否限制*/,其他状态);
    }
    return dp[index][limit][其他状态]=ans;//记忆化
}

long long solve(long long x){
    memset(dp,-1,sizeof(dp));//每次重新计算一个区间得初始化
    long long pos=0;//位数
    //拆分数
    while(x){
        num[pos++]=x%10;
        x/=10;
    }
    return dfs(pos-1/*最高位*/,1/*有限制*/,其他状态);//从高位向低位遍历
}
```


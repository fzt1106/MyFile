# 区间异或修改求和

## 问题描述

> 修改区间[l,r]：对该区间每一个数与x进行异或操作，并求和

对于暴力修改，需要$O(n)$。

但是若需进行多次区间修改，需要用到许多维护区间的数据结构：==线段树==。但是对于线段树数来说，上述操作无法在O(1)时间内完成。

## 思路

首先考虑从**二进制角度实现区间求和**，`num[i]`存储了区间[l,r]中每一个数在第i位为1的总个数，于是可以得到区间的和为$sum=\sum{num[i](1<<i)}$

其次考虑**异或对位操作的特点**

> 0、1与0异或，不需改变
>
> 0、1与1异或，需要取反

于是，若对区间每一数的第i位异或1（异或0不影响），每一个数的第i位取反，于是需进行如下修改：、

`修改后改为1的个数=区间长度-原该位1的个数：num[i]=(r-l+1)-num[i]`

每次一次区间修改都可以在$O(len(x))$时间内完成了，其中$len(x)=x的二进制表示下的长度$。

于是就是可以通过==线段树==维护该区间在每一个二进制位下1出现的个数

[例题：XOR on Segment](https://vjudge.net/contest/537315#problem/B)

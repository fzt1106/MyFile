[toc]

# 位运算

## 基本概念

### 运算规则

| 符号 | 描述 | 运算规则                                               |
| ---- | ---- | ------------------------------------------------------ |
| &    | 与   | 两个位都为1才为1，否则为0                              |
| \|   | 或   | 两个位都为0才为0，否则为1                              |
| ^    | 异或 | 两位相同为0，不同为1                                   |
| ~    | 取反 | 1变0，0变1                                             |
| >>   | 右移 | 各二进制位右移若干位，无符号位高位补0、有符号位高位补1 |
| <<   | 左移 | 各二进制位左移若干位，低位补0                          |

### 优先级

| 优先级 | 运算符                                                       | 结合性       |
| ------ | ------------------------------------------------------------ | ------------ |
| 1      | ++、--、！、-（负号运算符）、**~**                           | **自右至左** |
| 2      | *、/、%                                                      | 自左至右     |
| 3      | +、-                                                         | 自左至右     |
| 4      | **<<、>>**                                                   | 自左至右     |
| 5      | <、<=、>、=>                                                 | 自左至右     |
| 6      | ==、!=                                                       | 自左至右     |
| 7      | **&**                                                        | 自左至右     |
| 8      | **^**                                                        | 自左至右     |
| 9      | **\|**                                                       | 自左至右     |
| 10     | &&                                                           | 自左至右     |
| 11     | \|\|                                                         | 自左至右     |
| 12     | ? :                                                          | **自右向左** |
| 13     | 赋值运算符（=、+=、-=、/=、*=、%=、<<=、>>=、&=、\|=、^=、!=） | **自右向左** |

### 运算规则

| 运算规则                     | 运算规则                                                  |
| ---------------------------- | --------------------------------------------------------- |
| 交换律                       | a&b=b&a、a\|b=b\|a、a^ b=b^ a                             |
| 结合律（只能在同符号下进行） | (a&b)&c=a&(b&c)                                           |
| 等幂律                       | a&a=a、a\|a=a、（a^a=a不成立 ，a^a=0)                     |
| 零律                         | a&0=0                                                     |
| 互补律                       | a&~a=0、 a\|~a =a^~a =-1(所有位数都为1，有符号位时值为-1) |
| 同一律                       | a\|0=a、a^0=a                                             |
| 自反性                       | a^a=0                                                     |

### 负数位运算

​	正数补码是其本身

​	负数补码**符号位不变，其余按位取反，最后加1**

### 原反补码

​	原码->补码:数值为取反＋1

​	补码->原码:对该补码的数值位继续取反+1

​	补码的绝对值(称为真值):正数的真值就是本身,负数的真值是各位(包括符号位)取反+1(即变成原码并把符号位取反❓)

---

## 位运算高级操作

下面是对单独一个位的位运算总结，我认为是比较重要的：

1. ==**位|位0=位、位|1=1、位|位=位**==
2. ==**位&位0=0、位&位1=位、位&位=位**==
3. ==**位^0=位、 位^1=~位、 位^位=0**==

| 功能 |
| ---- |

| 功能               | 示例                                         | 位运算      |
| ------------------ | -------------------------------------------- | ----------- |
| 去掉最后一位       | 0101->0010                                   | x>>1        |
| 在最后加一个0      | 0010->0100                                   | x<<1        |
| 在最后加一个1      | 0100->1001                                   | (x<<1)+1    |
| 将最后一位变为1    | 0100->0101                                   | x\|1        |
| 将最后一位变为0    | 0101->0100(先确保最后一位为1在减1)           | (x\|1)-1    |
| 最后一位取反       | 0100->0101                                   | x^1         |
| 把右数的第k位变为1 | 0010->0110 (k=3)                             | x\|(1<<k-1) |
| 把右数的第k位变位0 | 0110->0010 (k=3)（先变成0100，再取反，再与） | x&~(1<<k-1) |
| 把右数的第k位取反  | 0110->0010 (k=3)                             | x^(1<<k-1)  |
|                    |                                              |             |

|                          | 示例                                                      | 位运算                                    |
| ------------------------ | --------------------------------------------------------- | ----------------------------------------- |
| 取末k位                  | 1011->0011,(k=2)                                          | x&(1<<k)-1                                |
| 取右数的第k位            | 1011->0001,(k=4)（右移k-1位则是去掉了k-1位，与保留第k位） | x>>(k-1)&1                                |
| 把末k位全变成1           | 1000->1111,(k=3)                                          | x\|(1<<k)-1                               |
| 把末k位取反              | 1001->1010,(k=2)                                          | x^(1<<k)-1                                |
| 把右起连续的1变为0       | 0111->0000                                                | x&(x+1)                                   |
| 把右起连续的0边为1       | 0100->0111                                                | x&(x-1)                                   |
| 取右边连续的1            | 1011->0011                                                | (x^(x+1))>>1                              |
| 去掉右起第一个1的左边    | 1010->0010                                                | x&(x^(x-1))                               |
| 把最左边的1的右边都变为1 | 00100111->001111111                                       | x\|=>>1;x\|=>>2;x\|=>>4;x\|=>>8;x\|=>>16; |
| 取最左边的1              | 00100111->000100000                                       | 在上面那一步后(x+1)>>1                    |



---

## 位运算的歪门邪道

### 1.-1的判断

#### 原理

-1的补码为11111111

按位取反后就变成00000000，即为0

#### 用到处

==链式向星式中判断边是否遍历完==

---

### 2.取最低位的1

#### 原理

把最底位的1不变，其它位**按位取反**，利用**x&~x=0**可得到最低位的1

具体实现：**x&-x**

#### 用到处

==树状数组==

---

### 3.位运算实现乘除2

#### 原理

将x左移一位实现乘2、将x右移一位实现除2

**a<<1==a*2 **

**a>>1==a/2 **

#### 用到处

==快速幂运算==

---

### 4.位运算交换两整数

#### 原理

**```a^a=0,位a^位0=a```**

```c++
void swap(int & a,int & b){
    a^=b;
    b^=a;
    a^=b; 
}
```

根据**交换律和结合律**b= b ^ b ^ a=0 ^ a=a

同理a=(a ^ b) ^ a=b

---

### 5.位运算判断奇偶数

#### 原理

最低二进位决定奇偶，最底位为1则为奇、最底位为0则为偶

提取二进制最低位与1进行与运算（在和1进行与运算中就相当于提取了二进制最低位），为1则为奇、为0则为偶

```c++
if((x&1)==1)//奇数
if((x&1)==0)//偶数
```



---

### 6.位运算找出没有重复的数

> 给你一组数据，这组数据中其中有一个数只出现了一次，其余数都出现了两次，找出出现一次的数

#### 原理

**```a^a=0,位a^位0=a```**

比如1,2,3,4,5,4,3,2,1

全都把他们异或一遍即是结果

#### 代码

```c++
int find(int a[]){
    int x=a[0];
    for(int i=1;i<a.length;i++)x^=a[i];
    return x;
}
```

时间复杂度O(n),空间复杂度O(1)

#### 变题

> 给你一组数据，这组数据中其中有两个数只出现了一次，其余数都出现了两次，找出出现一次的数

​	思路和上面一样，我们有个问题是如何找出分别找出只出现一次的两个数x、y

​	如1，2，3，4，5，3，2，1 return4，5

​	我们把它们全都异或一遍后，得ans!=0，且ans=x^y;

​	**利用ans二进制位上的1处，x、y的二进制位在此处相异的特点**，把x、y分到两个集合中，那集合中出现两次数和上面一样被异或掉了，就可以找到一个集合中只含x，从而可以找到y=x^ans;

#### 代码

```c++
int pair<int,int >(int a[]){
    int ans=a[0];
    for(int i=1;i<a.length;i++){
        ans^=a[i];
    }
    int temp=ans;
    int count=0;
    while((temp&1)==0){
        count++;
        temp>>=1;
    }
    int x=0;
    for(int i=0;i<a.length;i++){
        if(((a[i]>>count)&1)){
            x^=a[i];
        }
    }
    int y=x^ans;
    return pair<int,int>(x,y);
} 
```



---

### 7.位运算计算m的n次方(快速幂运算)

#### 原理

对于n=13，其二进制为1101

  计算m^n^时，可以把其拆分为$m^{1101}=m^{0001}*m^{0100}*m^{1000}$[快速幂运算](E:\Typora算法笔记\数论\数论笔记\数论笔记之快速幂运算.md)==通过位运算可以更好理解快速幂运算，通过快速幂运算可以更好理解下面程序==

==位运算很多情况下和二进制扯上关系，判断是否可以位运算，可以把它们拆分成二进制，观察特性，或者利用与、或、异或的特性来观察==

可以通过**&1和>>1**来逐位读取1101

```c++
int pow(int n){
    int result=1;
    int tmp=m;
    while(n!=0){
        if(n&1){
            result*=tmp;
        }
        tmp*=tmp;
        n>>=1;
    }
    return sum;
}
```

复杂度接近于O(logn)

---

### 8.位运算找出不大于N的最大的2的幂指数

#### 原理

例如19，其二进制位为（以8位为例）：00010011

答案是：00010000

即**最左边的1保留，后面的1全部变为0**

1. 把**最左边的1的右边全部变为1** 得到：00011111
2. 加1 得到：00100000
3. 右移一位 得到：00010000

把==最左边的1保留，后面的1全部都变为0==

```c++
n|=n>>1;
n|=n>>2;
n|=n>>4;
```

​	我们记最左边的1在从左往右数的第k为

​	把n右移1位后并做或运算，就可以把第k、k+1位变为1

​	再把n右移2位后并做或运算，就可以把k、k+1、k+2、k+3位变为1

​	继续从重复操作，就可以把k、k+1、k+2、k+3…………k+7**最多8位**变为1了，我们是以8位二进制位为例，所以**最多8位**足以把**最左边的1的右边都变为1了**

```c++
int find(int n){
    n|=n>>1;
    n|=n>>2;
    n|=n>>4;
    n|=n>>8;
    n|==n>>16;
    return (n+1)>>1;
}
```

**复杂度O(1)**

---

### 9.位运算改变正负性和求绝对值

#### 原理

1. 改变正负性

   ```c++
   int change(int a){
       return ~a+1;
   }
   ```

   对正数而言：补码就是原码，其取反加1就是负数的补码

   对负数而言：其补码进行按位取反再加1则得到对应真值正数的补码，变为原码❓

2. 求绝对值

   ```c++
   int abs(int a){
       return (a^(a>>31))-(a>>31)//注意优先级，-比>>和^高
   }
   ```

   先判断改数为正数还是负数

   **右移31位，若为0则为正数、若为-1则为负数（有符号为高位补1）**

   0的补码为0000、-1的补码为1111

   然后利用```位a^位0=a,位a^位1=~a```

---

### 10.位运算实现对p取余(p为2^k^)

#### 原理

取余实际上是**舍去大于等于p的位数,所以我们只需保留在p范围内的数**

由于我们限定p=2^k^,所以**p-1将小于p的最高位全变为1**,在进行**与**即可得到余数

```c++
int mod(int a,int p){
    return a&(p-1);
}
```

---

### 11.统计二进制数的1个数

#### 原理

**a&(a-1)把从右数的第一个1变为0**

比如uuu1000,把它减1后得uuu0111,二者进行与运算得uuu0000

不断把右数的第一个1变为0,并记录1的个数

```c++
int count(int x){
    int cnt=0;
    while(x!=0){
        x&=(x-1);
        cnt++;
    }
    return cnt;
}
```

---

### 12.位运算实现加法

#### 原理

先来看一下十进制中的加法运算

> 15+7
>
> 第一步:**不进位加法**:
>
> 1. 第一位5+7=2
> 2. 第二位:1+0=1
> 3. 得12
>
> 第二步:**进位加法**:
>
> 1. 第一位:5+7>=10, 进一位得10
> 2. 第二位:1+0<10,不进位
> 3. 得10
>
> 第三步:**不进位加法+进位加法**
>
> 1. 12+10
> 2. 得22

在来看看二进制中的加法运算

1. 二进制中的不进位加法

   > 0011+0010
   >
   > 不进位加法原则
   >
   > 1. 1+1=0
   > 2. 1+0=1
   > 3. 0+1=1
   > 4. 0+0=0
   >
   > 得0001

   可以把**二进制中不进位加法中+替换成^,效果一样**

   >1. 1^1=0
   >2. 1^0=1
   >3. 0^1=1
   >4. 0^0=0

   总结:==**异或运算**就是二进制加法运算中的**不进位加法**==

2. 二进制中进位加法

   >0011+0010
   >
   >进位加法原则
   >
   >1. 1+1=0(当前位的值进1位)
   >2. 1+0=1(当前位的值不进位)
   >3. 0+1=0(当前位的值不进位)
   >4. 0+0=0(当前位在值不进位)
   >
   >得0100

   可以把**二进制中进位加法替换成&**

   > 1. 1&1=1(进一位)
   > 2. 1&0=0(不进位)
   > 3. 0&1=0(不进位)
   > 4. 0&0=0(不进位)

   总结:==**与运算**就是二进制加法运算中的**进位加法**,可通过**位运算符实现进位**==

3. 进位加法与不进位加法相加的

   0011+0010=0001+0100=0101

在第四步中,我们又用了**+**,但是其实那也是**两个二进制位相加**,所以可以继续用**位运算加法**

```c++
int add(int a,int b){//当进位为0时跳出
    int sum=0;
    while(b!=0){//直到没有进位
        sum=a^b;//sum=非进位和
        b=(a&b)<<1;//sum=进位和
        //记录下分进位和与进位和,下一次二进制运算循环继承用位运算加法
        a=sum;
    }
}

//码风优化
int add(int a,int b){
    return b?add(a^b,(a&b)<<1):a;
}
```

==**定理1**:设a,b为两个二进制数,则**a+b=a^b+(a&b)<<1**==

==**定理2**:重复利用定理1可以实现**只用位运算的加法**==

---

### 13.位运算实现减法

#### 原理

在十进制减法可定义为a-b=a+(-b)

在二进制减法中,两个二进制数相减可定义为**a-b=a+(-b)==a+(~b+1)**

---

### 14.位运算实现乘法

#### 原理

就像对我们十进制中的计算

在二进制乘法计算中去模拟一下乘法,**其中还是要用到位运算加法**

![image-20220407214737340](E:\Typora算法笔记\位运算\位运算笔记\位运算笔记.assets\image-20220407214737340.png)

可以看到:

1. 在乘数最低位为0时,其对结果没有影响,跳过(但别忘了把被乘数右移,乘数左移)

2. 在乘数最低位为1时,其对结果有影响,进行二进制加法运算(之后也得把被乘数右移,乘数左移)

3. 对于负数,我们先用绝对值进行正数乘法运算,之后在判断正负

   **异或运算**判断符号位

   1. a^b=负数,即符号为**异号**,结果为负数
   2. a^b=正数,即符号为**同号**,结果为正数

```c++
//正数乘法运算
int chenfa1(int a,int b){
    int ans=0;
    while(b){//直到乘数为0时结束
        if((b&1)){//当乘数的最低位为1时,会对乘法结果产生影响
            ans=add(a,b);//进行二进制加法运算
        }
        a<<=1;//被乘数左移
        b>>=1;//乘数右移
    }
    return ans;
}

//含负数乘法运算
int chenfa2(int a,int b){
    int a1=(a^(a>>31))-(a<<31);
    int b1=(b^(b>>31))-(b<<31);//先取ab绝对值进行正数乘法运算
    int ans=chenfa1(a,b);
    if((a^b)<0){//若符号位位异号
        ans=add(~ans,1);//按位取反+1
    }
}
```

---

### 15.位运算实现除法

#### 原理

 相当于乘法的逆运算，不断减去除数，直到被除数小于除数：此时减的次数就是商，此时的被除数就是余数

为了提高效率，以被除数的2^n^倍来作为减数,从2^31^开始判断，因为int的最高位（数字位）为31位，而2^n^可以通过**<<,>>**来实现

但要注意，为了**不让被除数溢出，我们不能把除数b进行b<<n的操作，而是把被除数a进行a>>n的操作，效果相同**

商的符号位：**同乘法判断**

余数的符号为：**与被除数符号位相同**

```c++

int chufa1(int a,int b){
    int a1=(a^(a>>31))-(a<<31);
    int b1=(b^b(b>>31))-(b<<31);//先取绝对值计算正数乘法
    int shang=0;
    int yushu=0;
    for(int i=31;i>=0;i++){
        if((a1>>i)>=b1){//若a>(b*(2^i))时
            shang=add(shang,1<<i);//商＋2^i
            a1=add(a1,~(b1<<i)+1);//被除数a减去除数b的2^n倍
        }
    }
    yushu=a1;
    if(a^b<0)shang=(~shang,1);//若ab异号，商为负数，商取反加1
    if(a>>31==-1)yushu=(~yushu,1);//求余符号位取决于被除数a的符号
    return shang;//return yushu
}
```

---



### 16.二进制O(1)时间检测2的幂次

#### 原理

​	首先地特判2^k^是否大于0

​	其次我们知道2^k^在二进制位中只有1个1,我们可以利用**x&(x-1)**来消除唯一的1判断是否为0

#### 代码

````c++
bool judge(int n){
    if(!n)return false;
    else{
        n=n&(n-1);
        if(n)return false;
        else return true;
    }
}

//码风优化
bool judge(int n){
    return n>0&&(n&(n-1))==0;
}
````

#### 复杂度

**O(1)**

---



### 17.计算将整数a转换为整数b需要改变多少个bit位

#### 原理

​	将整数a转化为整数b，若两对应bit位相同则不需要改变、若两对应bit位不相同则需要改变

​	而相同与不同可以交给**异或运算**，a^b后相同的bit位为0、不同的bit位为1

​	问题就变成了判断异或后1的个数了

#### 代码

```c++
int sum(int a,int b){
    int c=a^b;
    int count=0;
    while(!c){
        c=c&(c-1);
        count++;
    }
    return count;
}
```

----



### 18.位运算的本质

1. &的本质，相当于十进制中==相同位做加法的1/2==

   > 例如：0101&0011结果为：二进制0001
   >
   > 利用相同为做加法的1/2计算，结果为：十进制（2^0^+2^0^)/2=1

2. |的本质，相当于十进制中==相同位做加法的1/2与不同位做加法求和==

   > 例如：0101|0011   结果为：二进制0111
   >
   > 利用相同位做加法的1/2与不同位做加法求和计算，结果为：十进制(2^0^+2^0^)/2+2^1^+2^2^

3. ^的本质，相当于十进制中==不同位做加法的==

   > 例如：0101|0011 结果为：二进制0110
   >
   > 利用不同位做加法，结果为：十进制2^1^+2^2^

4. ```>>```的本质，相当于十进制中的==除2==

5. ```<<```的本质，相当于十进制中的==乘2==

理解了这个针对感觉二进制于十进制运算直接的关系太妙了

**在看看上面第13.位运算实现加法(a^b)+(a&b)<<1**,利用上述原理分析：

1. a、b不同位做加法
2. a、b相同位做加法的1/2的2倍
3. 1+2==十进制：a+b

**(a&b)+(a|b)**:

1. a、b相同位做加法的1/2
2. a、b相同位做加法的1/2+a、b不同位做加法
3. 1+2==十进制：a+b

**(a&b)+(a^b)<<1**:

1. a、b相同位做加法的1/2
2. a、b不同位做加法的1/2
3. 1+2==十进制 (a+b)/2

---

### 19.二进制枚举

[集合的整数表示(二进制枚举)文件](E:\Typora算法笔记\位运算\位运算笔记\集合的整数表示笔记.md)

[集合的整数表示(二进制枚举)网站]([集合的整数表示(二进制枚举)_meet snow happy的博客-CSDN博客](https://blog.csdn.net/m0_64109657/article/details/124110147?spm=1001.2014.3001.5502))



